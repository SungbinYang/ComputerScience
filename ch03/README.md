> 이 강좌는 [널널한 개발자님의 강의](https://www.inflearn.com/course/%EB%84%93%EA%B3%A0%EC%96%95%EA%B2%8C-%EC%BB%B4%EA%B3%B5-%EC%A0%84%EA%B3%B5%EC%9E%90/dashboard)를 기반으로 작성한 글입니다.

## 동시성과 병렬성

### 동시성

여러 가지 일이 동시에 진행되는 것!

예를들어, 라면먹는 일과 TV보는 일은 하나의 독립적인 개별 사건이다. 이 일을 문제 없이 동시에 할 수 있으면 이 사건들은 동시성이 있다라고 말할 수 있다. 만약 그게 동시에 일어날 수 없다면 동시성이 없다는 것으로 말할 수 있다. 또 다른 예를 들어보자. 우리가 어떤 게임을 설치받고 있다고 하자. 그 게임을 설치받는 동안 우린 크롬에서 유뷰트를 접속하여 영상을 시청이 가능하다. 이 2개의 사건은 동시성이 있다고 볼 수 있다. 서로의 사건이 상호간섭없이 연산하고 실행이 가능하기 때문이다.

어떻게 보면 번갈아가면서 독립적인 개별 사건을 처리하는 것도 동시성이라고 볼 수 있다.
또 다른 예로 하나의 커피머신에 n개의 줄이 있고 번갈아가며 커피를 타는 모습이 동시성이 있다고 볼 수 있다.

즉, 다시 요약하자면 동시성이란 **서로 다른 2가지 일이 동시에 일어나는 것**이라고 볼 수 있다.

### 병렬성

동시성과 같이 쓰이는 용어가 병렬성이다.

**같은 일**을 여러 주체가 함께 동시에 진행하는 것!

예를들어, 인형 눈을 붙이는 작업이 있다고 하자. 그런데 이 작업을 하는 사람이 1명일때 보단, 여러사람이 작업을 하는게 더 효율적일 것이다. 이런 인형에 눈 붙이는 일은 병렬성이 있다라고 말할 수 있다.

즉, 어떻게 보면 병렬성 또한 동시성 범주에 포함될 수 있을 것이다.

병렬성은 동시성과 달리 물리적으로 동시에 정확히 실행되는 것을 말한다.

그럼 이런 병렬성은 어디서 확인이 가능할까? 바로, 비트코인의 채굴이 이런 병렬성을 띄운다. 코인을 채굴할때 GPU를 통하여 해시연산을 하는 작업인데 그래픽카드의 GPU 여러 유닛이 이 작업을 진행하는것이다. 이것을 병렬성이라고 볼 수 있다. 또 다른 예로 영상처리를 할때 픽셀단위로 합성을 하는데 이것도 여럿이 진행을 하면 더 빨리 가능함으로 이런 영상처리도 병렬성을 이용한다고 볼 수 있다.

또 다른 예로 n개의 커피머신의 n개의 줄이 있는 모습을 볼 수 있다. 이 때 각 커피머신마다 하나의 줄을 가지고 있어 각각의 줄마다 커피를 받아가는 모습이 병렬성이 있다고 볼 수 있다.

## 원자성, 동기화 그리고 교착상태

### 원자성

동시성을 애기하면 따라오는 단어가 원자성이다. 동시성은 저번에 설명했듯이, A라는 일과 B라는 일이 서로 상호간섭없이 일을 하는 것이 동시성이라고 하는데 만약에 A라는 일과 B라는 일이 어떤 요소를 동시에 접근하고 먼저 선점하려고 노력한다고 보자. 쉽게 애기하면 화장실을 들어가는 예를 들어보자. 화장실을 순서로 표현하면 다음과 같을 것이다.

1.  화장실을 가고싶어하는 신호를 받는다.
2.  화장실로 향한다.
3.  노크를 한다.
4.  진입을 한다.
5.  볼일을 보고 물을 내린다.
6.  손을 씻는다.
7.  화장실에 나온다.

이런 순서에서 가장 중요한 부분이 3번과 4번과정 사이이다. 3번과정에 노크하는 과정은 화장실이라는 자원을 다른 누군가가 선점하였는지 조사를 하는 행위이며, 진입과정은 화장실이라는 자원을 아무도 선점하지 않았을 때, 진행이된다. 이때, 화장실 문을 잠구듯이 선점된 자원을 Lock을 건다. 그리고 손을 씻는 행위까지 Lock이 걸리다가 화장실을 나오는 순간에 Unlock을 해줌으로 자원을 반납하는 행위를 한다. 즉, Lock이 걸린 부분들 4~ 6번까지의 과정이 원자성이 보장된다고 할 수 있다. 만약 노크를 하는 과정에 누군가가 있다고 하면 wait을 해야하는 과정이 있다. 그런데 만약 집에서 나 혼자 자취를 하는 상황이라면 3번 노크하는 과정은 없을 것이다. 즉, 원자성은 동시성이 발생 안되었을 때는 항상 보장받기 때문에 따로 신경을 안써줘도 된다.

### 동기화

동기화는 우리가 익숙하게 아는 용어처럼 보인다. 원본이 변경되었을 때 사본을 '동기화'해준다는 표현을 많이 쓸 것이다. 하지만 지금부터 설명하려는 용어는 이것과 다른 용어이다.

동기화란 신호등과 잠금 장치의 필요성과 유사하다.

위의 화장실 예를 들어보면 우린 화장실을 들어갈지 안 할지 노크하는 과정으로 판단한다. 또한 교통체계에서 이 길을 건너도 되는지 아닌지 판별은 신호등으로 판별한다. 즉, 이런 상황을 정리해주는 판별해주는 것을 동기화라고 말할 수 있다. 이런 동기화과정 즉, 이런 판별장치 혹은 장금장치를 OS에서 보통 제공해준다.

### 교착상태(DeadLock)

휴지가 없어서 못 나가는 자, 나와야 들어가는 휴지 든 자

항상 동기화 개념이 나오면 문제가 되는 것이 논리적인 오류 문제가 나오는데 바로 이런 문제를 교착상태라고 한다. 예를들어보면 내가 화장실이라는 자원을 선점해서 볼일을 보고 있다고 가정하자. 그런데, 이제 휴지로 마무리를 할려고 하는데 휴지가 없다고 가정해보자. 그러면 나는 나가지도 못하고 wait라는 상태가 되고 휴지라는 자원을 기달리게 된다. 즉, 휴지라는 자원이 없어서 나는 기달리게 되는데 밖에 화장실이라는 자원이 필요한 다른 누군가는 휴지라는 자원을 가지고 있다고 해보자. 즉, 화장실 밖 사람은 내가 나오기를 화장실이 Unlock이 되기를 기다라는 것이다. 즉, 지금 상황이 이러지도 저러지도 못하는 상태가 되었는데 이런 상태를 바로 DeadLock이라고 부른다. 이런 상태의 원인 논리적인 하자로 인하여 발생한다.

즉, 우리가 S/W를 개발할 때, 발생가능한 오류나 예외상황을 생각하지 않고 개발할 때 나올 수 있는 상태이다. 또한 프로그램 2개나 동시성 이슈가 터지면서 시스템이 무너지는 현상이 발생할 수 있다. 또한 무언가를 우리가 접근함에 있어서 이것을 접근하는거든 연산을 하든 여러 연산주체가 동시에 접근할때 발생할 문제를 막기 위해서 Lock도 걸고 동기화도 하면서 원자성을 보장받지만 그게 잘못된 특히, 외부자원에 대한 무언가를 요구함으로써 특히 양단간에 의존성이 존재하는 자원들끼리 동시에 무언가 하다가 교착상태에 빠질 수 있다.

## 컴퓨터의 구성요소와 아바타

### 컴퓨터의 구성요소

- Computer는 H/W와 S/W로 구성된다.
- S/W는 Application과 System S/W로 구분된다.
- 가장 대표적인 System S/W는 OS이다.

### 프로그램, 프로세스, 스레드

- 프로그램은 설치하는 것이다.
- 설치된 프로그램을 실행하면 운영체제가 설치된 프로그램을 프로세스로 만들어준다.
- 프로세스는 환경적(관리) 단위이다.
- 프로세스는 PID라고 사람으로 치면 주민등록번호같은 것을 부여받는다.
- 스레드는 프로세스 속에 존재하는 실행(연산)단위이다.
- 스레드 단위로 실행(연산)이 된다.
- 프로세스는 적어도 1개이상의 스레드를 가지고 있다.
- 스레드는 프로세스에게 할당된 자원(메모리)을 공유한다.
- OS는 메모리같은 전산자원(메모리)을 프로세스에게 부여하고 그 부여받은 자원을 스레드들이 같이 사용한다.
- **컴퓨터라는 세상에서 당신의 유전자는 프로그램이고, 프로세스라는 모습으로 존재한다.**

쉽게 보면 우리가 메이플이라는 게임을 통하여 막 사냥을 하고 퀘스트를 하고 할 것이다. 이때, 우리는 메이플이라는 것을 로그인 한다. 이 때 '나'라는 프로세스가 생성이 되는 것이다. 이 때, '나'라는 프로세스가 컴퓨터에서 쉘이 되는 것이다. 즉, 우리가 컴퓨터를 키고 로그인 하면 가장 먼저 작동되는 것이 shell이다.

### 용도에 따른 기억공간의 구분

기억공간 즉, 메모리라는 것이 용도에 따라 구분이 된다. 가장 대표적인 공간이 stack,heap이라는 공간이다. stack이라는 공간은 스레드가 사용하고 있으며, heap이라는 공간은 프로세스 전체가 사용하고 있다. 쉽게 애기하면 stack은 각자 방을 의미하고 heap은 거실처럼 공용공간을 뜻한다. 그럼 예를 들어 스레드가 4개가 동작한다고 보면 stack도 4개가 존재한다고 봐도 된다. 그럼 왜 공간을 구분했을까? 왜냐하면 동시성 문제라던데 앞에서 설명한 문제들을 해결하기 위하여 공간구분을 한 것이다.

## 국가와 국민으로 이해하는 컴퓨터 세상

## 국가와 국민으로 이해하기

국가(근대국가)라는 것이 존재할려면 영토, 영공, 영해가 존재해야하며, 주권과 정부영역, 민간영역이 존재해야 한다. OS를 이해하는 데 있어서 갑자기 국가가 나오는지 이해가 안 될것이다. 좀 더 다른 비유를 들어보자. 어떤 요소가 있다고 보자. 요소가 레이어 구조로 계층적으로 탑처럼 쌓여있다고 볼 때, 가장 아래에 있는 요소는 위에 있는 요소에 존립기반이 된다. 즉, 가장 아래에 있는 요소가 없고서는 위의 요소도 없다는 의미이다. 다른 의미로는 존립기반을 전제조건이라고도 말할 수 있는 것이다. 그러면 위의 요소는 그 아래의 요소에 대해서 존립 자체라고 말할 수 있으며 다른 말로는 의존적이다라고 말할 수 있다.

다시 국가차원으로 돌아가자면 정부영역은 영토, 영공, 영해에 대해서 의존적이며 민간영역은 정부영역에 대해서 의존적이다라고 할 수 있다. 다시애기해보면 영토는 물리적인 요소이고 정부영역은 행정조직이기 때문에 다시 말하면 논리적인 조직이다라고 말할 수 있다. 그리고 민간영역에는 '나'라는 요소가 있고 '나'라는 요소는 하나의 주거공간을 가지게 된다. '나'라는 요소 뿐만 아니라 다른 국민들도 존재하고 그 국민들도 각자의 공간을 가지게 된다.

그러면 국가를 컴퓨터라는 것으로 보면 다음과 같을 것이다. 영토, 영공, 영해는 H/W인것이고 정부영역, 민간영역을 S/W라고 볼 수 있다. 그리고 S/W는 Application과 System S/W로 나눠지는데 이것은 각각 민간영역과 정부영역으로 볼 수 있을 것이다. 그런데 System S/W에서 가장 대표적인 것이 OS가 있다고 볼 수 있다. 또한 Application은 국민이라는 요소가 있는데 이것을 프로그램이다라고 보면 프로그램을 실행시킬 때 하나의 메모리 공간을 가지는데 그것은 결국 국민+주거공간 = 프로세스라고 볼 수 있다.

그러면 갑자기 어떤 B라는 국민이 화장실이 급해서 A라는 국민의 허락없이 화장실을 이용할 수 있을까? 대한민국 헌법상 주거침입죄로 불법행위이다. 이것을 누가 막아주고 있을까? 애기했듯이 대한민국 정부가 헌법을 통하여 막고 있다. 즉, 컴퓨터로 애기하면 프로세스가 다른 프로세스의 메모리 공간을 침입을 할 경우 OS가 막아준다. 만약 그럼에도 불구하고 그런 행위를 시도할려고 하면 OS에서 화를 내듯이 '삐'하고 그 행위를 멈추게 한다. 즉, 이런 상황이 발생할 때 우리는 흔히 프로그램이 죽었다라고 말한다. 사실 죽었다기 보다는 OS가 그 행위를 멈추게 한것이다. 또한, 이렇게 국민영역에 수 많은 프로세스 동시에 존재하는 환경을 멀티태스킹 환경이라고 한다.

추가적으로, 어떤 국민이 남의 주거공간을 침입할 수 있는 조건도 있다. 우리나라의 검찰이나 경찰이 영장을 국가로부터 부여받으면 수색을 할 수 있는데 이것은 컴퓨터환경에서 Debugger라고 부른다. 또한 OS의 핵심을 이루는 알맹이를 kernel이라고 부른다. kernel의 가장 큰 역할은 접근 통제의 역할을 한다.
