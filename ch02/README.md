> 이 강좌는 [널널한 개발자님의 강의](https://www.inflearn.com/course/%EB%84%93%EA%B3%A0%EC%96%95%EA%B2%8C-%EC%BB%B4%EA%B3%B5-%EC%A0%84%EA%B3%B5%EC%9E%90/dashboard)를 기반으로 작성한 글입니다.

## 디지털 회로와 덧셈

### 디지털 회로

디지털 회로를 우리가 왜 배울까? 뭐 면접에도 나오기도 하고 각 종 시험에서 나오기도 하지만 근본적인 이유는 바로 CPU를 제작하기 위해서이다. 여기서 의문이 드는게 그럼 CPU는 왜 우리가 만들어야 할까? 이미 대기업에서 만들어진 CPU를 잘 사용하면 된다. 하지만 이것이 어떻게 만들어지고 동작이 되는지는 알고 쓰면 더 좋기 때문이며 그게 근간하는 내용이 디지털 회로이다. 아래의 그림은 각 연산 gate들의 진리표이므로 잘 숙지해둬야 한다.

![](https://velog.velcdn.com/images/bini/post/5b65f42c-1daa-4e17-b5e0-4b1517bad543/image.png)

그러면 원래 CPU는 뭐하는 것인가? 간단히 애기하면 '전자계산기'라고 한다. 여기서 '전자'라는 말이 중요한데 왜 전자를 사용할까? 빛이나 물을 이용할 수는 없을까? 물론 이용이 가능하지만 전자를 사용하는 이유는 빠르기 때문이다. 그럼 어떤 계산기일까? 바로 산수연산에 대한 계산기이다.

즉, CPU를 만들고 싶다고 하면 산수 계산기를 만들면 되고 산수의 기본이 되는 +기능부터 만들면 된다.

> 여기서 잠깐, 위의 표에서 input으로 들어가는 a,b는 하나하나가 1bit라고 할 수 있다.

### 컴퓨터가 덧셈하는 방법

- 2진수 1 + 1은 2진수 10(2) 이다.
- A가 1, B가 1이면 XOR 연 산결과 S는 0이다.
- 동시에 A가 1, B가 1이면 AND 연산결과 C는 1이다. 이 1은 자리 올림(Carry)이다.
- 두 수를 더할 수 있으면 CPU를 만들 수 있다.

![](https://velog.velcdn.com/images/bini/post/1db4fef9-826d-411b-959e-307021eb1bf7/image.png)

위의 그림은 반가산기로 덧셈을 해주는 기계이다. 그것을 논리회로로 표현한 것이다. 하지만 이것은 1bit한정이며 예를들어 8bit끼리 덧셈을 할려고 하면 자리올림또한 생각을 해줘야 함으로 반가산기로는 부족하다. 그래서 나온 회로가 전가산기다. 전가산기는 아래와 같다.

![](https://velog.velcdn.com/images/bini/post/d18ad136-3eca-4b6f-8f05-eb01a56402a1/image.png)

전가산기를 병렬로 이어서 다양한 bit의 계산이 가능하다.

### 수제 CPU

![](https://velog.velcdn.com/images/bini/post/d0dc1735-b40c-4f00-8b26-6676ea282c53/image.jpg)

[홈브류 cpu](http://www.homebrewcpu.com/)

## 컴퓨터가 뺄셈하는 방법

- 6에 4를 더하면 10이다. 즉, 4는 6에 대 한 10의 보수이다.
- 13 – 6은 7이다.
- 13에 6에 대한 10의 보수 4를 더하고 10 자리에서 1을 빼도 역시 7이다.
- 2진수에서 0은 1로, 1은 0으로 뒤집으면 1의 보수가 된다.
- 1의 보수에 1을 더하면 2의 보수이다.
- 어떤 숫자에 2의 보수를 더하면 자동으로 2진수 뺄셈이 된다. 단, 자리올림은 버린다.

뺄셈 애기가 나오면 항상 나오는 키워드가 보수이다. 즉, 뺄셈은 보수의 덧셈이라고 볼 수 있다. 즉, 전에 배웠던 전가산기에 input을 보수값을 넣어주면 된다. 즉, 2진수도 비슷하다. 2진수는 1의 보수를 구한 다음에 더하기 1만 해주면 된다.

> 2의 보수 = 1의 보수(not gate) + 1

이렇게 보면 뺄셈도 덧셈의 응용편이다. 그럼 이제 곱셈과 나눗셈이 문제인데 이것도 마찬가지다. 곱셈은 여러번 덧셈을 하는 것이고 나눗셈은 여러번 뺄셈을 하는 것이다. 즉, 모든 사칙연산이 덧셈에 근간한거고 CPU도 사칙 계산기로 덧셈에 근간한다고 볼 수 있다.

## CPU가 곱하고 나누는 방법

### 컴퓨터가 곱셈 하는 방법

곱셈은 여러번 더하면 되긴 하지만 이 방법은 너무 비효율적이라 다른 메커니즘(shift 연산)을 이용하게 된다. 아래 내용을 살펴보자.

-   4비트로 5를 표현하면 0101 이다.
-   4비트 0101을 왼쪽으로 한 칸 씩 밀면(Shift) 1010이다.
-   맨 오른쪽에 0이 채워진다. (Padding)
-   4비트로 표현하는 2진수 1010은 10이다.
-   왼쪽으로한칸밀면곱하기 2, 두 칸 밀면 곱하기 4가 된다.

![](https://velog.velcdn.com/images/bini/post/7b3c4996-edea-4eb4-92e2-efd917db9eb4/image.png)


### 컴퓨터가 나눗셈 하는 방법

나눗셈은 여러번 빼면 되긴 하지만 이 방법은 너무 비효율적이라 다른 메커니즘(shift 연산)을 이용하게 된다. 아래 내용을 살펴보자.

-   4비트로 6를 표현하면 0110이다.
-   4비트 0110을 오른쪽으로 한 칸씩 밀면 0011이다.
-   맨 왼쪽에 0이 채워진다. (Padding)
-   4비트로 표현하는 2진수 0011은 3이다.
-   7을 0을 나누면?
-   7에서 0을 빼면 7이고 7은 0보다 크다.
-   7에서 0을 계속 빼면 언젠 가는 0보다 작은 숫자를 만 날 수 있는가?
-   만날 수 없다면 뺄셈 연산은 언제 끝날까?
	-> 이런 연산을 하게 되면 보통의 CPU에서는 에러가 발생한다. 하자만 ATMEGA128같은 CPU에서는 연산을 무한정하게 됨으로 연산할때마다 열에너지가 발생하고 결국 폭발하게 된다. 그걸 시연한 분이 있는데 아래 동영상 링크로 남겨보겠다.

![](https://velog.velcdn.com/images/bini/post/934e8c41-e510-4a8d-aa8f-f738576cfc63/image.png)


[나눗셈 링크](https://www.youtube.com/watch?v=mZ7pUADoo58)