> 이 강좌는 [널널한 개발자님의 강의](https://www.inflearn.com/course/%EB%84%93%EA%B3%A0%EC%96%95%EA%B2%8C-%EC%BB%B4%EA%B3%B5-%EC%A0%84%EA%B3%B5%EC%9E%90/dashboard)를 기반으로 작성한 글입니다.

## 디지털 회로와 덧셈

### 디지털 회로

디지털 회로를 우리가 왜 배울까? 뭐 면접에도 나오기도 하고 각 종 시험에서 나오기도 하지만 근본적인 이유는 바로 CPU를 제작하기 위해서이다. 여기서 의문이 드는게 그럼 CPU는 왜 우리가 만들어야 할까? 이미 대기업에서 만들어진 CPU를 잘 사용하면 된다. 하지만 이것이 어떻게 만들어지고 동작이 되는지는 알고 쓰면 더 좋기 때문이며 그게 근간하는 내용이 디지털 회로이다. 아래의 그림은 각 연산 gate들의 진리표이므로 잘 숙지해둬야 한다.

![](https://velog.velcdn.com/images/bini/post/5b65f42c-1daa-4e17-b5e0-4b1517bad543/image.png)

그러면 원래 CPU는 뭐하는 것인가? 간단히 애기하면 '전자계산기'라고 한다. 여기서 '전자'라는 말이 중요한데 왜 전자를 사용할까? 빛이나 물을 이용할 수는 없을까? 물론 이용이 가능하지만 전자를 사용하는 이유는 빠르기 때문이다. 그럼 어떤 계산기일까? 바로 산수연산에 대한 계산기이다.

즉, CPU를 만들고 싶다고 하면 산수 계산기를 만들면 되고 산수의 기본이 되는 +기능부터 만들면 된다.

> 여기서 잠깐, 위의 표에서 input으로 들어가는 a,b는 하나하나가 1bit라고 할 수 있다.

### 컴퓨터가 덧셈하는 방법

- 2진수 1 + 1은 2진수 10(2) 이다.
- A가 1, B가 1이면 XOR 연 산결과 S는 0이다.
- 동시에 A가 1, B가 1이면 AND 연산결과 C는 1이다. 이 1은 자리 올림(Carry)이다.
- 두 수를 더할 수 있으면 CPU를 만들 수 있다.

![](https://velog.velcdn.com/images/bini/post/1db4fef9-826d-411b-959e-307021eb1bf7/image.png)

위의 그림은 반가산기로 덧셈을 해주는 기계이다. 그것을 논리회로로 표현한 것이다. 하지만 이것은 1bit한정이며 예를들어 8bit끼리 덧셈을 할려고 하면 자리올림또한 생각을 해줘야 함으로 반가산기로는 부족하다. 그래서 나온 회로가 전가산기다. 전가산기는 아래와 같다.

![](https://velog.velcdn.com/images/bini/post/d18ad136-3eca-4b6f-8f05-eb01a56402a1/image.png)

전가산기를 병렬로 이어서 다양한 bit의 계산이 가능하다.

### 수제 CPU

![](https://velog.velcdn.com/images/bini/post/d0dc1735-b40c-4f00-8b26-6676ea282c53/image.jpg)

[홈브류 cpu](http://www.homebrewcpu.com/)

## 컴퓨터가 뺄셈하는 방법

- 6에 4를 더하면 10이다. 즉, 4는 6에 대 한 10의 보수이다.
- 13 – 6은 7이다.
- 13에 6에 대한 10의 보수 4를 더하고 10 자리에서 1을 빼도 역시 7이다.
- 2진수에서 0은 1로, 1은 0으로 뒤집으면 1의 보수가 된다.
- 1의 보수에 1을 더하면 2의 보수이다.
- 어떤 숫자에 2의 보수를 더하면 자동으로 2진수 뺄셈이 된다. 단, 자리올림은 버린다.

뺄셈 애기가 나오면 항상 나오는 키워드가 보수이다. 즉, 뺄셈은 보수의 덧셈이라고 볼 수 있다. 즉, 전에 배웠던 전가산기에 input을 보수값을 넣어주면 된다. 즉, 2진수도 비슷하다. 2진수는 1의 보수를 구한 다음에 더하기 1만 해주면 된다.

> 2의 보수 = 1의 보수(not gate) + 1

이렇게 보면 뺄셈도 덧셈의 응용편이다. 그럼 이제 곱셈과 나눗셈이 문제인데 이것도 마찬가지다. 곱셈은 여러번 덧셈을 하는 것이고 나눗셈은 여러번 뺄셈을 하는 것이다. 즉, 모든 사칙연산이 덧셈에 근간한거고 CPU도 사칙 계산기로 덧셈에 근간한다고 볼 수 있다.

## CPU가 곱하고 나누는 방법

### 컴퓨터가 곱셈 하는 방법

곱셈은 여러번 더하면 되긴 하지만 이 방법은 너무 비효율적이라 다른 메커니즘(shift 연산)을 이용하게 된다. 아래 내용을 살펴보자.

- 4비트로 5를 표현하면 0101 이다.
- 4비트 0101을 왼쪽으로 한 칸 씩 밀면(Shift) 1010이다.
- 맨 오른쪽에 0이 채워진다. (Padding)
- 4비트로 표현하는 2진수 1010은 10이다.
- 왼쪽으로한칸밀면곱하기 2, 두 칸 밀면 곱하기 4가 된다.

![](https://velog.velcdn.com/images/bini/post/7b3c4996-edea-4eb4-92e2-efd917db9eb4/image.png)

### 컴퓨터가 나눗셈 하는 방법

나눗셈은 여러번 빼면 되긴 하지만 이 방법은 너무 비효율적이라 다른 메커니즘(shift 연산)을 이용하게 된다. 아래 내용을 살펴보자.

- 4비트로 6를 표현하면 0110이다.
- 4비트 0110을 오른쪽으로 한 칸씩 밀면 0011이다.
- 맨 왼쪽에 0이 채워진다. (Padding)
- 4비트로 표현하는 2진수 0011은 3이다.
- 7을 0을 나누면?
- 7에서 0을 빼면 7이고 7은 0보다 크다.
- 7에서 0을 계속 빼면 언젠 가는 0보다 작은 숫자를 만 날 수 있는가?
- 만날 수 없다면 뺄셈 연산은 언제 끝날까?
  -> 이런 연산을 하게 되면 보통의 CPU에서는 에러가 발생한다. 하자만 ATMEGA128같은 CPU에서는 연산을 무한정하게 됨으로 연산할때마다 열에너지가 발생하고 결국 폭발하게 된다. 그걸 시연한 분이 있는데 아래 동영상 링크로 남겨보겠다.

![](https://velog.velcdn.com/images/bini/post/934e8c41-e510-4a8d-aa8f-f738576cfc63/image.png)

[나눗셈 링크](https://www.youtube.com/watch?v=mZ7pUADoo58)

## 컴퓨터가 연산하는 과정

컴퓨터라고 하면 기본적으로 CPU를 의미하며 그 외 나머지 장치들은 CPU를 보조하는 장치이다. 하지만 우리는 컴퓨터라고 하면 CPU에 RAM까지 포함시켜서 생각을 하면 좋을 것 같다.

CPU는 연산하는 장치이며 RAM은 메모리(정보 저장) 반도체이다. 여기서 컴퓨터가 연산할때 주로 보조기억장치(SSD, HDD)에서 CPU로 가져와서 연산을 한다. CPU로 가져오는 과정은 우리가 직접 하지 않고 거의 HDD수준이나 운영체제에서 자동으로 알아서 해준다.

![](https://velog.velcdn.com/images/bini/post/8358aa97-5d24-425c-8a0c-9a9b62431b18/image.png)

위의 그림을 자세히 보면 RAM에는 수많은 일련번호가 있는데 일련번호의 value값에다가 메모리를 저장해준다. 여기서 0,1번은 주로 OS에서 사용을 한다. 이 과정은 우리가 엑셀을 작성하는 것과 유사하다고 생각하면 된다. 즉, 우리가 연산하는 결과를 RAM의 일련번호의 저장소에 담는데 이 일련번호의 저장소의 값을 CPU의 레지스터라는 임시 저장소에 담는다. 그 임시저장소의 값을 ALU라는 장치를 통해 연산을 하여 결과 값이 나오게 된다. 그 결과 값을 메모리의 일련번호의 저장소에 담게 된다. 그럼 일련번호는 무한대로 존재하는가? 그건 아니고 RAM의 bit수의 따라 다르다. 일반적으로 64bit를 사용함으로 일련번호는 2^64byte까지 존재한다.

즉, 결론을 보면 CPU에서 연산을 한다는 것은 RAM이 엄청 중요한 역할을 하고 있다는 것이다. 그리고 여기서 RAM을 1차 메모리라고 한다. 그리고 HDD나 SSD같은 보조기억장치들을 2차 메모리라고 한다.

## 컴퓨터가 기억공간을 관리하는 방법

### 기억장치의 종류와 역할

![](https://velog.velcdn.com/images/bini/post/8148e09d-231b-4b81-8232-53e2ec93d1cc/image.png)

기억 장치는 여러 분류로 나눠지는데 CPU가 가지고 있는 메모리 장치인 레지스트리가 있으며, RAM이라는 1차메모리와 HDD, SDD등 2차메모리가 존재한다.  
여기서 가장 핵심은 레지스트리이며 여기까지 값을 가져와야 연산을 하든 무엇을 하든 진행이 가능하다.

속도차원에서 봤을때 가장 빠른 속도는 레지스터가 가장 빠르며 RAM에 비해 4배정도 더 빠르다. 또한 레지스터와 2차메모리의 속도 차이는 비행기와 사람이 걸어가는 속도차이라고 보면 좋을 것이다. 그래서 레지스터와 2차메모리와 속도차이가 너무 크기때문에 이것을 극복하기위해 RAM과 L1~L3 캐시 메모리가 존재한다.

레지스터와 RAM까지의 특징이 있는데 휘발성 메모리라는 특징이다. 즉, 전원을 꺼버리면 다 날라간다는 특징이 있다.  
위의 그림을 보면 레지스터로 올라갈 수록 극소량의 메모리 + 가격이 비싸며 2차 메모리로 올라갈 수록 가격이 싸고 대량 메모리로 저장 할 수 있다.  
그럼 좀 궁금한게 L1~L3까지의 캐시메모리는 어떤 역할을 할까? RAM의 정보들을 미리 예측하여 CPU가 캐시 메모리에 저장을 해두어서 RAM에서 복사하는 과정을 최소화한다. 물론 CPU 예측이 틀려서 fault가 날 때는 RAM에서 정보를 복사해와야 하는 경우가 있다. 만약 RAM에도 찾는 정보가 없다고 하면 2차메모리에서 찾아야 하고 거기도 없으면 예외가 발생한다. 프로그래밍으로 치면 `NullPointerException`이 발생하는 것이다.

즉, CPU와 보조기억장치의 속도차이를 극복하기 위하여 RAM이 존재하는 것이다.

예를 한번 들어보자. 우리가 SSD에 OS를 설치하고 OS를 실행한다고 해보자. 그러면 그 OS정보를 RAM에 copy가 된다. 그리고 그 OS의 명령들을 CPU에 보내서 실행하게 되는 것이다.

### 컴퓨터가 기억공간을 관리하는 방법

- 컴퓨터는 기본적으로 모든 것이 다 ‘숫자’이다.
- 정보가 저장된 위치도 ‘숫자’ (보통은 일련번호(메모리 주소))로 표시한다.
- 이같은관리체계는아파트단지에서각가구를동,호숫자로관리하는것 과 유사하다.
- 레지스터, 주 기억장치(RAM), 보조 기억장치(HDD, SSD)를 관리하는 방 법은 조금씩 다르다.
  - 레지스터는 개별 기억공간마다 고유 이름을 붙인다.
  - 주 기억장치는 일련번호를 붙인다.
  - 보조기억장치는 트랙(Track) 번호와 섹터(Sector) 번호를 붙여 관리한다. (파일(File)의 등장!)

## HDD,SSD와 파일시스템

레지스터는 CPU의 가장 핵심 장치이며 각 요소마다 이름이 존재한다. RAM은 요소마다 일련번호가 붙고 이것을 메모리 주소라고 한다. 그 요소는 용량이 1byte단위로 관리가 된다.

### HDD의 논리적 구조

HDD 구조는 아래의 그림처럼 구성되어 있으며 HDD 속도를 말할 때는 HDD의 spindle이 돌아가는 속도로 따진다. 즉 HDD의 Head가 spindle을 돌면서 정보를 읽는다.

![](https://velog.velcdn.com/images/bini/post/c9473e15-0884-4743-980b-e5ec69f5f842/image.png)

HDD를 논리적으로 보았을 때 어떤 개념으로 관리체계를 나누는데 바로 트랙과 섹터로 나눠진다. 섹터쪽에서 우리의 정보를 기술 할 수 있는데 이 기술된 정보를 우리는 Read 혹은 Write를 할 수 있다. 여기서 좀 알아둬야 할것이 있는데 하나의 섹터의 write가 되어있는 상태에서 또 write를 하면 overwrite가 되는데 이 과정을 몇 수십만번 반복하면 이 섹터는 더 이상 사용이 불가능하다. 이런 경우를 Bad Sector라고 한다. 물론 이런것은 OS가 빈공간에서 알아서 write를 해주기 때문에 우리는 크기 신경을 안써도 되지만 이런 증상이 일어날 수 있으니 알아두자. 섹터 하나당 용량은 512byte정도 된다.

### 조각모음의 의미

섹터 하나당 크기가 512byte라고 했는데 만약 파일 크기가 1MB라고 하고 저장을 한다 했을 때 섹터를 연속적으로 write를 한다면 좋지만 연속적으로 될 수 있는 경우가 있다. 그럴 때 마다 트랙을 옯겨서 워프를 하는데 이 과정이 HDD 물리적으로 디스크가 돌아야 하기 때문에 I/O 성능이 떨어진다. 그런데 조각모음을 하면 연속적으로 정보를 write할 수 있도록 다른 정보를 다른 트랙으로 이사시키는 과정이라고 보면 된다. 하지만 이 조각모음은 옛날에나 사용했고 요즘은 OS가 알아서 해준다.

![](https://velog.velcdn.com/images/bini/post/b7eaf280-acd7-4368-a4c1-c35bbf4dab13/image.jpg)

### 주 기억장치 공간은 ‘일련번호’로 관리한다.

### 파일이 저장되는 방법 (파일시스템)

각 OS마다 파일시스템은 다르며, 윈도우 같은 경우에는 NTFS라는 파일시스템을 사용한다. 어느 파일이 몇번 트랙 몇번 섹터 저장된 파일 이름을 표형태로 저장하는데 이것을 file allocation이라고 하고 모든 파일 시스템이 이 표형태를 다 가지고 있다. 그럼 만약에 파일을 삭제했을 경우 어떻게 될까? 0으로 overwrite하는게 아니고 파일명 앞에 ##을 붙이고 deleted라는 컬럼에 체크를 해두는 형태로 진행한다. 그래서 삭제되었던 파일이 복원도 가능한것이다.

또한 알아두어야 할 용어가 있는데 0번 트랙 0번 섹터에 있는 것을 마스터 부트 레코드라고 부른다. 이 마스터 부트 레코드에는 일반 파일정보가 들어가는 것이 아니라 OS의 부트 로더라는 코드가 들어간다. 즉, 마스터 레코드에 정보를 꺼내서 메모리에 적재하면서 메모리등 기타장치들을 체크하는 과정이 있는게 이것을 부팅한다라고 한다.

그리고 포맷이라는 용어가 있는데 디스크를 포맷한다라는 의미는 디스크의 file allocation형식을 바꾸거나 FAT의 데이터를 날린다고 보면 된다.

자세히 보면 빠른 포맷이라고 하면 FAT테이블 데이터를 날려버리는 것이고 느린 포맷은 트랙과 섹터들을 0으로 overwrite하는것으로 보면 된다.
